==============
Sorts Builders
==============

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. _sorts-builders:

Overview
--------

In this guide, we show you how to use **builders** to specify
**sort criteria** for your queries.

Sort criteria are the rules by which data is sorted. Some examples of sort criteria are:

* Smallest number to largest number
* Earliest to latest time of day
* Alphabetical order by first name 

Builders are classes provided by the MongoDB Java driver that allow you to use
the builder pattern to interact with your MongoDB instance.
The builder pattern is an Object Oriented design technique for creating complex
immutable objects seperately from their representation.

You should read this guide if you would like to use the builder pattern
to specify sort criteria for your queries. If you are new to sorting in the
MongoDB Java driver, consider reading our
:doc:`CRUD Sort Guide </fundamentals/crud/read-operations/sort/>`
for a general sort introduction.

The Sorts Class
---------------

The :java-docs:`Sorts <apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html>`
class is the sort criteria builder provided by the MongoDB Java Driver.
``Sorts`` provides static factory methods for all
sort criteria operators supported by MongoDB. Each method returns
an instance of the
:java-docs:`Bson <apidocs/bson/org/bson/conversions/Bson.html?>`
type. 

The following examples will show you how to use the static factory
methods from the ``Sorts`` class to sort your queries.
The examples use a sample collection ``sort_example`` containing
the following documents:

.. code-block:: none

   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 6, "letter": "c", "food": "maple donut"}


Ascending
---------

To specify an ascending sort, use the ``Sorts.ascending()``
static factory method. This will sort your results
from smallest to largest on the field name specified.

In the following code snippet, we use ``ascending`` to
sort the ``sort_example`` collection by ``number``:

.. code-block:: java
   
   import static com.mongodb.client.model.Sorts.ascending;

   // <MongoCollection setup code here>
   
   Bson number_sort = ascending("number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet should look something like this: 

.. code-block:: none

   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   ...
   
An important thing for you to keep in mind is that MongoDB does
not guarentee sort order for fields with identical values.
This means that ``asending("letter")`` could have any of these three
documents in any of the first three positions: 

.. code-block:: none

   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 2, "letter": "a", "donuts and coffee"}

If you would like to have a guarenteed sort order for fields
with identical values, you can specify additional fields to sort
on in the event of a tie. 

In the following code snippet, we use ``ascending`` to
sort the ``sort_example`` collection on ``letter`` followed
by ``number``:

.. code-block:: java

   import static com.mongodb.client.model.Sorts.ascending;

   // <MongoCollection setup code here>
   
   Bson letter_number_sort = ascending("letter", "number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(letter_number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet should look something like this: 

.. code-block:: none

   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 6, "letter": "c", "food": "maple donut"}


Descending
----------

To specify a descending sort, use the ``Sorts.descending()``
static factory method. A descending sort will return results
from largest to smallest.

In the following code snippet, we use ``descending`` to
sort the ``sort_example`` collection by ``number``: 

.. code-block:: java
   
   import static com.mongodb.client.model.Sorts.descending;

   // <MongoCollection setup code here>
   
   Bson number_sort = descending("number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet should look something like this: 

.. code-block:: none

   {"number": 6, "letter": "c", "food": "maple donut"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 1, "letter": "c", "food": "coffee with milk"}

It is important for you to keep in mind that ``descending``
does not provide guarentees on sort order in the event of identical values.
This means that ``descending("letter")`` could return either of these two
documents in the first position:

.. code-block:: none

   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 6, "letter": "c", "food": "maple donut"}

If you would like to have a guarenteed sort order for fields
with identical values, you can specify additional fields to sort
on in the event of a tie. 

In the following code snippet, we use ``descending`` to
sort the ``sort_example`` collection on ``letter`` followed
by ``number``:

.. code-block:: java

   import static com.mongodb.client.model.Sorts.descending;

   // <MongoCollection setup code here>
   
   Bson letter_number_sort = descending("letter", "number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(letter_number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet should look something like this: 

.. code-block:: none

   {"number": 6, "letter": "c", "food": "maple donut"}
   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}


Text Score
----------

If you are using :manual:`$text </reference/operator/query/text/>`
queries to search your data, you can sort the results of those
queries by text score (how well the search matched the returned document).
To create a sortable field on the 
:manual:`$meta </reference/operator/aggregation/meta/#exp._S_meta>`
``"textScore"`` associated with a ``$text`` search, use the
``Sorts.metaTextScore(<fieldname used in projection>)`` static factory method to retrieve
a ``Bson`` document that can be added to your query results using
:java-docs:`projection <apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#projection(org.bson.conversions.Bson)>`. 
You can then use the ``Sorts`` class to sort on ``"<fieldname used in projection>"``.

The ``$text`` command performs a text search on the content indexed by the 
:manual:`text index </core/index-text/>` on your collection.
To add a text index to the ``sort_example`` collection on the ``"food"`` field,
go into the ``mongo`` shell and run the following command:

.. code-block:: js

   db.sort_example.createIndex({
     "food": "text"
   })

To see that the index was created successfully, run the following command in the ``mongo`` shell:

.. code-block:: js

    db.test.getIndexes().filter(index => index.name === "food_text")[0]

Your output should look something like this: 

.. code-block:: none

   {
   	"v" : 2,
   	"key" : {
   		"_fts" : "text",
   		"_ftsx" : 1
   	},
   	"name" : "food_text",
   	"weights" : {
   		"food" : 1
   	},
   	"default_language" : "english",
   	"language_override" : "language",
   	"textIndexVersion" : 3
   }

Once you create your text index on the ``"food"`` field, you can use the
following code snippet to search on the ``"food"`` field for the term 
``"maple donut"`` and sort the results:

.. code-block:: java

   import static com.mongodb.client.model.Sorts.metaTextScore;
   import static com.mongodb.client.model.Sorts.ascending;
   import static com.mongodb.client.model.Projections.excludeId;
   import static com.mongodb.client.model.Projections.fields;

   // <MongoCollection setup code here>
   
   String projectedSortField = "textScore";
   Bson metaTextScore = metaTextScore(projectedSortField);
   // build projection using the Projections builders
   Bson metaTextProjection = fields(excludeId(), metaTextScore);
   String searchTerm = "maple donut";
   Bson searchQuery = new Document("$text", new Document("$search", searchTerm));
   collection.find(searchQuery)
           .projection(metaTextProjection)
           .sort(ascending(projectedSortField))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet should look something like this: 

.. code-block:: none

   {"number": 2, "letter": "a", "food": "donuts and coffee", "textScore": 0.75}
   {"number": 3, "letter": "a", "food": "maple syrup", "textScore": 0.75}
   {"number": 6, "letter": "c", "food": "maple donut", "textScore": 1.5}

Combining Sort Criteria
-----------------------

To combine sort criteria, use the ``Sorts.orderBy()``
static factory method. The ``orderBy()`` method applies additional
sort criteria from left to right in the event of ties. 

In the following code snippet, we use ``orderBy`` to combine a
``descending`` on ``letter`` with an ``ascending`` sort on number.

.. code-block:: java

   import static com.mongodb.client.model.Sorts.orderBy;

   // <MongoCollection setup code here>

   Bson orderBySort = orderBy(descending("letter"),
           ascending("number"));
   collection.find()
           .sort(orderBySort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet should look something like this: 

.. code-block:: none

   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 6, "letter": "c", "food": "maple donut"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}