==============
Sorts Builders
==============

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. _sorts-builders:

Overview
--------

In this guide, we show you how to specify **sort criteria** for your
queries using **builders**.

Sort criteria are the rules MongoDB uses to sort your data. Some
examples of sort criteria are:

* Smallest number to largest number
* Earliest time of day to latest time of day
* Alphabetical order by first name 

The builder pattern allows you to create complex immutable objects
separately from their representation. :doc:`Builders </fundamentals/builders/>` 
are classes provided by the MongoDB Java driver that allow you to use
the builder pattern to construct
:java-docs:`Bson <apidocs/bson/org/bson/conversions/Bson.html>` objects.
The builders provided by the MongoDB Java driver can improve the
readability of your code.

You should read this guide if you would like to:

* Use the builder pattern to specify sort criteria for your queries.
* Perform ascending sorts and descending sorts.
* Combine sort criteria.
* Sort on the text score of a
  :manual:`text search </core/text-search-operators/>`.

If you want to learn the fundamentals of sorting in the MongoDB Java
driver, consider reading our
:doc:`guide on sorting </fundamentals/crud/read-operations/sort/>`.

The Sorts Class
---------------

The :java-docs:`Sorts </apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html>`
class is a builder that provides static factory methods for all sort criteria
operators supported by MongoDB. These methods return a
:java-docs:`Bson </apidocs/bson/org/bson/conversions/Bson.html>`
object that you can pass to the 
:java-docs:`sort() </apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#sort(org.bson.conversions.Bson)>`
method of a ``FindIterable`` instance. 

.. _sorts-builders-sort-example:

The following examples show you how to use the methods
provided by the ``Sorts`` class to sort your queries. The examples use a
sample collection, ``sort_example``, that contains the following documents:

.. code-block:: json

   {"_id": 1, "letter": "c", "food": "coffee with milk"}
   {"_id": 3, "letter": "a", "food": "maple syrup"}
   {"_id": 4, "letter": "b", "food": "coffee with sugar"}
   {"_id": 5, "letter": "a", "food": "milk and cookies"}
   {"_id": 2, "letter": "a", "food": "donuts and coffee"}
   {"_id": 6, "letter": "c", "food": "maple donut"}


Sorting Direction
-----------------

The ``Sorts`` class provides methods for specifying the direction of your sort.
The direction of your sort can either be **ascending**, or **descending**.
An ascending sort orders your results from smallest to largest. A
descending sort orders your results from largest to smallest.

Here are some examples of data sorted in ascending order:

* Numbers: 1, 2, 3, 43, 43, 55, 120
* Dates: 1990-03-10, 1995-01-01, 2005-10-30, 2005-12-21 
* Words (alphabetical): Banana, Dill, carrot, cucumber, hummus

Here are some examples of data sorted in descending order:

* Numbers: 100, 30, 12, 12, 9, 3, 1
* Dates: 2020-01-01, 1998-12-11, 1998-12-10, 1975-07-22 
* Words (reverse alphabetical): pear, grapes, apple, Cheese

The following subsections show how to specify these sorts using
the ``Sorts`` class.

Ascending
~~~~~~~~~

To specify an ascending sort, use the ``Sorts.ascending()`` static
factory method. Pass ``Sorts.ascending()``
the name of the field you need to sort on.

The ``ascending()`` method can be used as follows:

.. code-block:: java

   import static com.mongodb.client.model.Sorts.ascending;

   // <MongoCollection setup code here>

   collection.find().sort(ascending("<field name>"));

The above ``sort()`` method returns a 
:java-docs:`FindIterable </apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html>`
object containing the documents in your collection, sorted from smallest
to largest on the specified field name. 

.. example::

   In this code example, we use the ``ascending()`` method to sort the
   :ref:`sort_example collection <sorts-builders-sort-example>`  
   by the ``_id`` field:

   .. code-block:: java
   
      import static com.mongodb.client.model.Sorts.ascending;
   
      // <MongoCollection setup code here>
      
      Bson idSort = ascending("_id");
      List<Document> results = new ArrayList<>();
      collection.find().sort(idSort).into(results);
      for (Document result : results) {
          System.out.println(result.toJson());
      }

   The output of the code snippet above should look something like this: 
   
   .. code-block:: json
   
      {"_id": 1, "letter": "c", "food": "coffee with milk"}
      {"_id": 2, "letter": "a", "food": "donuts and coffee"}
      {"_id": 3, "letter": "a", "food": "maple syrup"}
      ...

Descending
~~~~~~~~~~

To specify a descending sort, use the ``Sorts.descending()`` static factory
method. Pass ``Sorts.descending()`` the name of the field you need to sort on.

The following code snippet shows how to specify a descending sort on the
``_id`` field: 

.. code-block:: java
   
   import static com.mongodb.client.model.Sorts.descending;

   // <MongoCollection setup code here>
   
   collection.find().sort(descending("_id"));


The code snippet above returns the documents in the
:ref:`sort_example collection <sorts-builders-sort-example>`  
in the following order: 

.. code-block:: json

   {"_id": 6, "letter": "c", "food": "maple donut"}
   {"_id": 5, "letter": "a", "food": "milk and cookies"}
   {"_id": 4, "letter": "b", "food": "coffee with sugar"}
   ...

Handling Ties
~~~~~~~~~~~~~

MongoDB does not guarantee sort order for documents that have
fields with identical values. This means that if you pass "letter" to
the ``ascending()`` method and use the returned sort criteria to sort
the documents in the
:ref:`sort_example collection <sorts-builders-sort-example>`, the first
document returned could be any of the following documents:

.. code-block:: json

   {"_id": 3, "letter": "a", "food": "maple syrup"}
   {"_id": 5, "letter": "a", "food": "milk and cookies"}
   {"_id": 2, "letter": "a", "food": "donuts and coffee"}

If you need guaranteed sort order for documents that
have fields with identical values, you can specify additional fields to sort
on in the event of a tie.

We can specify an ascending sort on the ``letter`` field followed by the
``_id`` field as follows:

.. code-block:: java

   import static com.mongodb.client.model.Sorts.ascending;

   // <MongoCollection setup code here>
   
   collection.find().sort(ascending("letter", "_id"));

The code snippet above returns the documents in the
:ref:`sort_example collection <sorts-builders-sort-example>`  
in the following order: 

.. code-block:: json

   {"_id": 2, "letter": "a", "food": "donuts and coffee"}
   {"_id": 3, "letter": "a", "food": "maple syrup"}
   {"_id": 5, "letter": "a", "food": "milk and cookies"}
   {"_id": 4, "letter": "b", "food": "coffee with sugar"}
   {"_id": 1, "letter": "c", "food": "coffee with milk"}
   {"_id": 6, "letter": "c", "food": "maple donut"}

Combining Sort Criteria
-----------------------

To combine sort criteria, use the ``Sorts.orderBy()`` static factory
method. The ``orderBy()`` method builds sort criteria that apply passed 
in sort criteria from left to right in the event of ties. 

In the following code snippet, we use the ``orderBy()`` method to combine a
descending sort on the ``letter`` field with an ascending sort on the
``_id`` field.

.. code-block:: java

   import static com.mongodb.client.model.Sorts.orderBy;
   import static com.mongodb.client.model.Sorts.ascending;
   import static com.mongodb.client.model.Sorts.descending;

   // <MongoCollection setup code here>

   Bson orderBySort = orderBy(descending("letter"), ascending("_id"));
   collection.find().sort(orderBySort);

The code snippet above returns the documents in the
:ref:`sort_example collection <sorts-builders-sort-example>`
in the following order: 

.. code-block:: json

   {"_id": 1, "letter": "c", "food": "coffee with milk"}
   {"_id": 6, "letter": "c", "food": "maple donut"}
   {"_id": 4, "letter": "b", "food": "coffee with sugar"}
   {"_id": 2, "letter": "a", "food": "donuts and coffee"}
   {"_id": 3, "letter": "a", "food": "maple syrup"}
   {"_id": 5, "letter": "a", "food": "milk and cookies"}

Text Search
-----------

If you perform a text search on your collection with the
:manual:`$text </reference/operator/query/text/>` query operator, you 
can sort your results by how well they match your ``$search`` String using
:manual:`text score </reference/operator/aggregation/meta/#exp._S_meta>`. 
To sort your search results by the text scores associated with your text
search, use the ``Sorts.metaTextScore()`` static factory method. 

.. warning:: Make Sure to Create a Text Index

   The ``$text`` query operator performs a text search on the content indexed 
   by the :manual:`text index </core/index-text/>` of your collection.
   Therefore, you must create a text index on your collection before you
   can run a text search and use ``Sorts.metaTextScore()``.

.. example::

   In the following code example, we show how you can use the
   ``Sorts.metaTextScore()`` method to sort the results of a text
   search on the :ref:`sort_example collection <sorts-builders-sort-example>`.
   The code example uses the :doc:`Filters </fundamentals/builders/filters>`,
   :doc:`Indexes </fundamentals/builders/indexes>`, and
   :doc:`Projections </fundamentals/builders/projections>` builders.
   The code example performs the following actions:

   #. Creates a text index for your
      :ref:`sort_example collection <sorts-builders-sort-example>`
      on the ``food`` field.
   #. Runs your text search for the phrase "maple donut".
   #. Projects text scores into your query results as the
      ``score`` field. This projection is optional if your MongoDB instance is
      running MongoDB 4.4 or later. 
   #. Sorts your results by text score (best match first).

   .. code-block:: java
   
      import com.mongodb.client.model.Sorts;
      import com.mongodb.client.model.Projections;
      import com.mongodb.client.model.Filters;
      import com.mongodb.client.model.Indexes;

      // <MongoCollection setup code here>
      
      collection.createIndex(Indexes.text("food"));
      Bson metaTextScoreSort = Sorts.metaTextScore("score");
      Bson metaTextScoreProj = Projections.metaTextScore("score");
      String searchTerm = "maple donut";
      Bson searchQuery = Filters.text(searchTerm);
      collection.find(searchQuery)
              .projection(metaTextScoreProj)
              .sort(metaTextScoreSort)
              .into(results);
      for (Document result : results) {
          System.out.println(result.toJson());
      }
   
   The output of the code snippet above should look something like this: 
   
   .. code-block:: json

      {"_id": 6, "letter": "c", "food": "maple donut", "score": 1.5}
      {"_id": 2, "letter": "a", "food": "donuts and coffee", "score": 0.75}
      {"_id": 3, "letter": "a", "food": "maple syrup", "score": 0.75}

.. note:: MongoDB 4.4 ``$meta`` Behavior

  When using MongoDB 4.4 or later, projecting ``Projections.metaTextScore()`` 
  into your ``FindIterable`` instance is not necessary to sort on
  ``Sorts.metaTextScore()``. In addition, the field name of a ``$meta``
  text score aggregation operation used in a sort is disregarded by the
  query system. This means that the field name argument passed to
  ``Sorts.metaTextScore()`` is ignored in MongoDB 4.4 and later.

For more information, see the
:java-docs:`Sorts class API documentation </apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html>`.
See the server manual documentation for more information on the :manual:`$text </reference/operator/query/text/>`
query operator and the
:manual:`$meta </reference/operator/aggregation/meta/>`
aggregation pipeline operator.
