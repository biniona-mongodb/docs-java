==============
Sorts Builders
==============

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

.. _sorts-builders:

Overview
--------

In this guide, we show you how to use builders to construct sort
criteria for your queries. We will learn how to use the
:java-docs:`Sorts <apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html>`
class. 


The Sorts Class
---------------

The ``Sorts`` class provides static factory methods for all
sort criteria operators supported by MongoDB. Each method returns
an instance of the
:java-docs:`Bson <apidocs/bson/org/bson/conversions/Bson.html?>`
type. 

The following examples will show you how to use the static factory
methods from the ``Sorts`` class to sort your queries.
The examples use a sample collection ``sort_example`` constructed as 
follows:

.. code-block:: java
   
   // MongoDatabase database = <code to instantiate your database>;
   
   MongoCollection<Document> collection = database.getCollection("sort_example");
   Document doc1 = new Document("number", 1).append("letter", "c").append("food", "coffee with milk");
   Document doc2 = new Document("number", 3).append("letter", "a").append("food", "maple syrup");
   Document doc3 = new Document("number", 4).append("letter", "b").append("food", "coffee with sugar");
   Document doc4 = new Document("number", 5).append("letter", "a").append("food", "milk and cookies");
   Document doc5 = new Document("number", 2).append("letter", "a").append("food", "donuts and coffee");
   Document doc6 = new Document("number", 6).append("letter", "c").append("food", "maple donut");

   List<Document> documents = Arrays.asList(new Document[]{doc1, doc2, doc3, doc4, doc5});
   collection.insertMany(documents);

The above snippet populates the ``sort_example`` collection with five documents:

.. code-block:: none

   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 6, "letter": "c", "food": "maple donut"}


Ascending
---------

To specify an ascending sort, use the ``Sorts.ascending()``
static factory method. This will sort your results
from smallest to largest on the field name specified.

In the following code snippet, we use ``ascending`` to
sort the ``sort_example`` collection by ``number``:

.. code-block:: java
   
   import static com.mongodb.client.model.Sorts.ascending;

   // <MongoCollection setup code here>
   
   Bson number_sort = ascending("number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet looks something like this: 

.. code-block:: none

   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 6, "letter": "c", "food": "maple donut"}

An important thing for you to keep in mind is that MongoDB does
not guarentee sort order for fields with identical values.
This means that ``asending("letter")`` could have any of these three
documents in any of the first three positions: 

.. code-block:: none

   {"number": 3, "letter": "a"}
   {"number": 5, "letter": "a"}
   {"number": 2, "letter": "a"}

If you would like to have a guarenteed sort order for fields
with identical values, you can specify additional fields to sort
on in the event of a tie. 

In the following code snippet, we use ``ascending`` to
sort the ``sort_example`` collection on ``letter`` followed
by ``number``:

.. code-block:: java

   import static com.mongodb.client.model.Sorts.ascending;

   // <MongoCollection setup code here>
   
   Bson letter_number_sort = ascending("letter", "number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(letter_number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet looks something like this: 

.. code-block:: none

   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 6, "letter": "c", "food": "maple donut"}


Descending
----------

To specify a descending sort, use the ``Sorts.descending()``
static factory method. A descending sort will return results
from largest to smallest.

In the following code snippet, we use ``descending`` to
sort the ``sort_example`` collection by ``number``: 

.. code-block:: java
   
   import static com.mongodb.client.model.Sorts.descending;

   // <MongoCollection setup code here>
   
   Bson number_sort = descending("number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet looks something like this: 

.. code-block:: none

   {"number": 6, "letter": "c", "food": "maple donut"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}
   {"number": 1, "letter": "c", "food": "coffee with milk"}

It is important for you to keep in mind that ``descending``
does not provide guarentees on sort order in the event of identical values.
This means that ``descending("letter")`` could return either of these two
documents in the first position:

.. code-block:: none

   {"number": 1, "letter": "c"}
   {"number": 6, "letter": "c"}

If you would like to have a guarenteed sort order for fields
with identical values, you can specify additional fields to sort
on in the event of a tie. 

In the following code snippet, we use ``descending`` to
sort the ``sort_example`` collection on ``letter`` followed
by ``number``:

.. code-block:: java

   import static com.mongodb.client.model.Sorts.descending;

   // <MongoCollection setup code here>
   
   Bson letter_number_sort = descending("letter", "number");
   List<Document> results = new ArrayList<>();
   collection.find().sort(letter_number_sort)
           .projection(new Document("_id", 0))
           .into(results);
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet looks something like this: 

.. code-block:: none

   {"number": 6, "letter": "c", "food": "maple donut"}
   {"number": 1, "letter": "c", "food": "coffee with milk"}
   {"number": 4, "letter": "b", "food": "coffee with sugar"}
   {"number": 5, "letter": "a", "food": "milk and cookies"}
   {"number": 3, "letter": "a", "food": "maple syrup"}
   {"number": 2, "letter": "a", "food": "donuts and coffee"}

metaTextScore
-------------

To perform a sort on the 
:manual:`$meta </reference/operator/aggregation/meta/#exp._S_meta>`
``"textScore"`` associeated with a 
:manual:`$text </reference/operator/query/text/>` search, use the
``Sorts.metaTextScore()`` static factory method. The ``$text`` command
performs a text search on the content indexed by the 
:manual:`text index </core/index-text/>` on your collection. The ``textScore``
represents how well each document matched the given search term on the text index.

To add a text index to the ``sort_example`` collection on the ``"food"`` field,
go into the ``mongo`` shell and run the following command:

.. code-block:: js

   db.sort_example.createIndex({
     "food": "text"
   })

To see that the index was created successfully, run the following code:

.. code-block:: js

    db.test.getIndexes().filter(index => index.name === "food_text")[0]

Your output should look something like this: 

.. code-block:: none

   {
   	"v" : 2,
   	"key" : {
   		"_fts" : "text",
   		"_ftsx" : 1
   	},
   	"name" : "food_text",
   	"weights" : {
   		"food" : 1
   	},
   	"default_language" : "english",
   	"language_override" : "language",
   	"textIndexVersion" : 3
   }

Once your index on the ``"food"`` field is created, we can use the
following code snippet to search on the ``"food"`` field for the term 
"donut" and sort the results:

.. code-block:: java


   import static com.mongodb.client.model.Sorts.metaTextScore;
   import static com.mongodb.client.model.Sorts.ascending;
   import static com.mongodb.client.model.Projections.excludeId;
   import static com.mongodb.client.model.Projections.fields;

   // <MongoCollection setup code here>
   
   String projectedSortField = "textScore";
   Bson metaTextScore = metaTextScore(projectedSortField);
   // build projection using the Projections builders
   Bson metaTextProjection = fields(excludeId(), metaTextScore);
   String searchTerm = "maple donut";
   Bson searchQuery = new Document("$text", new Document("$search", searchTerm));
   collection.find(searchQuery)
           .projection(metaTextProjection)
           .sort(ascending(projectedSortField))
           .into(results);
   System.out.println("Meta Text Score");
   for (Document result : results) {
       System.out.println(result.toJson());
   }

The output of the above code snippet looks something like this: 

.. code-block:: none

   {"number": 6, "letter": "c", "food": "maple donut", "textScore": 1.5}
   {"number": 2, "letter": "a", "food": "donuts and coffee", "textScore": 0.75}
   {"number": 3, "letter": "a", "food": "maple syrup", "textScore": 0.75}